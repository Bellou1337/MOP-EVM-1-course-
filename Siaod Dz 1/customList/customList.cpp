#include <iostream>
using namespace std;

typedef struct Item
{
	//это указатель на следующую структуру, почему nullptr? потому что по стандарту
	// ещё нет следующего элемента
	Item* next = nullptr;
	//это указатель на предыдущую структуру, почему nullptr? потому что по стандарту
	// ещё нет предыдущего элемента
	Item* prev = nullptr;
	//это число, которое мы помещаем в структуру(может быть не только число, а что угодно
	// : char,double,float...)
	int data;

}Item;
//просто заменяем указатель на слово List
typedef Item* List;
//функция проверки листа на пустоту
bool customEmpty(List& );
//функция для добавления элемента в конец листа
void customPushBack(int, List& );
//функция для добавления элемента в начало листа
void customPushFront(int , List&);
//функция для удаления элемента в начале листа
void customPopFront(List&);
//функция для удаления элемента в конце листа
void customPopBack(List& );
//функция для вывода самого левого элемента
void customFront(List& );
//функция для вывода самого правого элемента
void customBack(List& );
//функция для добавления элемента между двумя другими
void customInsert(int , List& );
//функция для удаления элемента между двумя другими
void customErase(List& );


int main()
{
	//это для того , чтобы в консоль русские букавки выводить
	setlocale(LC_ALL, "Rus");

	//итак, чё тут происходит:
	//1)Head - это голова,т.e указатель на самый первый элемент в листе,т.к у нас ещё нет
	//первого элемента, то мы его как бы создаём, но даём ему nullptr,потому что ещё нечего
	//туда класть
	List Head = nullptr;
	//2)Tail - это хвост,т.е указатель на самый последний элемент, но т.к у нас ещё нет элементов
	//кроме головы, то Tail по стандарту ставится на Head
	List Tail = Head;
	//3)PointerForList -это обычный указатель, который будет пробегаться по всем элементам,
	//начиная с самого первого, поэтому я и поставил его на Head,потому что пока что Head
	//самый первый элемент по сути
	List PointerForList = Head;

	//тут я просто запустил цикл от 1 до 10, чтобы показать наглядно как работает лист
	for (int i = 1; i <= 10; i++)
	{
		//1)customEmpty
		//Как она работает? посмотрите в самом низу кода,где  написана сама эта функция
		//я там написал подробно
		bool checkerForEmptyPushBack = customEmpty(Head);
		//Если список пустой, то получается,что головы не существует, значит нам нужно
		//её заново создать
		if (checkerForEmptyPushBack)
		{
			//тут я уже голове присваиваю new Item,инициализируя уже сам список, это даёт
			// возможность положить уже туда первый элемент листа
			Head = new Item;
			//ну так как элемент пока один, то и хвост будет равен самому первому элементу
			//потому что он как бы первый и последний одновременно
			Tail = Head;
			//ну тут я уже кидаю указатель, который бегает по элементам на Head,т.к
			//пока только один элемент
			PointerForList = Head;
			//для простоты примера я буду заполнять лист элементами от 1 до 10
			//ну вот как раз в самый первый элемент я и закидываю в дату i
			Head->data = i;
		}
		else
		{
			//Как работает функция? посмотрите в самом низу кода,где  написана сама эта функция
			//я там написал подробно
			customPushBack(i, Tail);
			//ну и чтобы указатель бегал по самым последним элементам, то я его присваиваю хвосту,
			// потому что он всегда самый последний элемент
			PointerForList = Tail;
		}
	}

	//Как работает функция? посмотрите в самом низу кода,где  написана сама эта функция
	//я там написал подробно
	customPushBack(12, Tail);
	bool checkerForEmptyPushFront = customEmpty(Head);
	//опять проверка на пустоту списка
	if (checkerForEmptyPushFront)
	{
		Head = new Item;
		Tail = Head;
		PointerForList = Head;
		Head->data = 28;
	}
	else
	{
		//если список не пустой, то я тут добавляю в начало,
		//Как работает функция? посмотрите в самом низу кода,где  написана сама эта функция
		//я там написал подробно
		customPushFront(28, Head);
		//тут я просто решил добавить 28 в начало списка, это чисто для примера
	}

	//Как работает функция? посмотрите в самом низу кода,где  написана сама эта функция
	//я там написал подробно
	//тут я просто решил удалить 28, для примера опять же
	customPopFront(Head);
	
	//а тут я решил удалить самый последний элемент в листе
	customPopBack(Tail);

	//ставлю указатель на голову для прохода листа с самого начала
	PointerForList = Head;

	//бегу по элементам , пока они есть в списке
	while (PointerForList != nullptr)
	{
		//тут я решил добавить элемент между 5 и 4
		if(PointerForList->data == 5)
		{
			customInsert(19,PointerForList);
		}
		// а это просто переставляю указатель для обращения к следующему элементу
		PointerForList = PointerForList->next;
	}

	//опять ставлю указатель в самое начало, для прохода по листу
	PointerForList = Head;

	//бегу по элементам , пока они есть в списке
	while (PointerForList!=nullptr)
	{
		//тут я решил удалить число 2
		if(PointerForList->data == 2)
		{
			customErase(PointerForList);
		}
		// а это просто переставляю указатель для обращения к следующему элементу
		PointerForList = PointerForList->next;
	}
	//опять ставлю указатель в самое начало, для прохода по листу
	PointerForList = Head;

	//бегу по элементам , пока они есть в списке
	while (PointerForList != nullptr)
	{
		//а тут я вообще вывожу все элементы в списке, которые там существуют
		cout << PointerForList->data << endl;
		// а это просто переставляю указатель для обращения к следующему элементу
		PointerForList = PointerForList->next;
	}
	cout << endl;
	//это вывод головы и хвоста
	//Как работают функции? посмотрите в самом низу кода,где написана сама эта функция
	//я там написал подробно
	customFront(Head);
	customBack(Tail);

	return 0;
}
bool customEmpty(List& Head)
{
	//Как работает? тут всё достаточно просто. Как узнать когда в списке нет элементов?
	//правильно, посмотреть на голову( на самый первый элемент в списке)
	//если это нулевой указатель, т.е её просто не существует по каким-то причинам,мб так
	//произошло,что вы удаляли элементы из листа , и смогли удалить абсолютно всё
	//Так вот, если головы нет, то и список содержит 0 элементов, следовательно вернётся 1
	// это говорит о том,что список пустой, иначе вернётся 0
	return Head == nullptr;
}
void customPushBack(int element, List& Tail)
{
	//итак, в эту функцию мы заходим в том случае, если известно,что в листе есть хотя бы
	//один элемент, тут мы создаём новый объект,и получается,что за конец листа у нас
	//всегда отвечает Tail,так вот если новый созданный получается уже самый последний элемент
	//то мы должны значит и хвост перекинуть на него.Для этого я у нового элемента указатель
	//на предыдущий элемент ставлю на Tail,потому что у Tail есть только prev, next у него не
	// существет, ну поэтому он всегда и указывает на самый последний элемент,поэтому next
	// я присваиваю nullptr,дальше в самом уже Tail я у указателя на следующий элемент(next)
	// ставлю значение новой созданной структуры, потому что она теперь последняя и Tail уже
	//получается предпоследний,а значит next у него уже есть, ну а потом кладу значение и
	//Tail присваиваю новый созданный объект,чтобы хвост всегда был хвостом, типо теперь Tail
	// опять указатель на самый последний элемент в листе
	List tempPointer = new Item;
	tempPointer->prev = Tail;
	tempPointer->next = nullptr;
	Tail->next = tempPointer;
	tempPointer->data = element;
	Tail = tempPointer;

}
void customPushFront(int element, List& Head)
{
	//здесь точно такая же логика, как и у PushBack,но только тут не Tail, а Head
	List tempPointer = new Item;
	tempPointer->prev = nullptr;
	tempPointer->next = Head;
	tempPointer->data = element;
	Head->prev = tempPointer;
	Head = tempPointer;

}
void customPopFront(List& Head)
{
	//вот тут уже есть несколько случаев
	//if: перед тем как удалить нужно подумать о том, а что если в листе остался только
	// один элемент, если это не так, то тогда должна быть голова и следующий элемент,
	// вот в ифе я как раз это проверяю, типо next и сама голова не должны быть nullptr
	if (Head != nullptr && Head->next != nullptr)
	{
		//тут смысл в том,чтобы сделать указатель и кинуть его на голову, а голову
		//перекинуть на следующий элемент, вот... а потом указатель удаляем и готово
		List tempPointer = Head;
		Head = Head->next;
		Head->prev = nullptr;
		delete tempPointer;
		tempPointer = nullptr;
	}
	//вот сюда зайдёт в том случае, когда у нас только 1 элемент и это голова, по сути
	//это голова и хвост одновременно, потому что они указывают на один элемент,а он самый
	//первый и самый последний одновременно
	else if(Head!=nullptr && Head->next==nullptr)
	{
		//ну тут всё супер просто, берём и удаляем голову и всё
		delete Head;
		Head = nullptr;
	}
}
void customPopBack(List& Tail)
{
	//абсолютно тоже самое,что и PopFront, но только тут Tail, а не Head
	if (Tail != nullptr && Tail->prev != nullptr)
	{
		List tempPointer = Tail;
		Tail = Tail->prev;
		Tail->next = nullptr;
		delete tempPointer;
		tempPointer = nullptr;
	}
	else if (Tail != nullptr && Tail->prev == nullptr)
	{
		delete Tail;
		Tail = nullptr;
	}
}
void customFront(List& Head)
{
	//а это просто вывод значения головы, типо самого левого элемента
	cout << "Значение головы = " << Head->data << endl;
}
void customBack(List& Tail)
{
	//а это вывод самого правого
	cout << "Значение хвоста = " << Tail->data << endl;
}
void customInsert(int element,List& pointerForList)
{
	//тут всё немного сложнее
	//короче, надо запихать элемент между двумя, ну значит нам нужно создать элемент
	//который нужно пихать и засунуть в него значение,а дальше просто берём и левый элемент
	//соединяем с тем, который запихиваем и правый тоже, типо просто меняем значения у next
	// и prev
	List tempPointer = new Item;
	pointerForList->prev->next = tempPointer;
	tempPointer->prev = pointerForList->prev;
	tempPointer->next = pointerForList;
	pointerForList->prev = tempPointer;
	tempPointer->data = element;

}
void customErase(List& pointerForList)
{
	//тут нужно удалить элемент , значит кидаем на него второй указатель,кстати, функция
	//принимает указатель на элемент который нужно удалить, а функция , написанная выше
	// принимает указатель на элемент слева от которого нужно впихнуть другой элемент
	//итак, тут мы сделали указатель новый и поставили его на элемент , который нужно удалить
	// а дальше логика простая, мы меняем значения у next и prev для элемента слева и справа
	//ну потому что если мы удаляем какой-то элемент, то слева и справа должны быть ещё элементы
	// и нам нужно уже их соединить
	//после того, как соединили их, то удаляем указатель, ну тот самый элемент, который и нужно
	// удалить
	List secondPointer = pointerForList;
	pointerForList->prev->next = pointerForList->next;
	pointerForList->next->prev = pointerForList->prev;
	pointerForList = pointerForList->next;
	delete secondPointer;
	secondPointer = nullptr;
}